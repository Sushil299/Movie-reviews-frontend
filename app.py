# -*- coding: utf-8 -*-
"""movie_app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H6bvBO9a0cTKq-FrV8J_Zx2taSPGIrh7
"""

import streamlit as st
import requests
import plotly.express as px

# Backend URL
BACKEND_URL = "https://movie-reviews-backend.onrender.com"

# Streamlit UI
st.set_page_config(page_title="ğŸ¬ Movie Review Analyzer", layout="wide")

# Title with an Icon
st.markdown("""
<div style="text-align: center; font-size: 24px; font-weight: bold; color: #FF5733;">
ğŸš€ Say Goodbye to Fake Reviews! ğŸ¥
ğŸ” Get **Real & Unbiased** Movie Opinions from Reddit Discussions.
</div>
""", unsafe_allow_html=True)

# User Input
st.markdown("### ğŸ¥ Enter Movie Name")
movie_name = st.text_input("Movie Name", placeholder="e.g., Animal, Oppenheimer, Pathaan", label_visibility="collapsed")

if st.button("ğŸ” Analyze Movie"):
    if movie_name:
        with st.spinner("Fetching Reddit discussions..."):
            response = requests.get(f"{BACKEND_URL}/analyze", params={"movie_name": movie_name})

            if response.status_code == 200:
                api_data = response.json()
                analysis = api_data.get("analysis", {})

                # Display Results
                st.subheader("ğŸ“¢ TL;DR Summary")
                st.success(analysis.get("tldr", "No summary available."))

                # Sentiment Analysis Visualization
                st.subheader("ğŸ“Š Sentiment Analysis")
                sentiment = analysis.get("overallSentiment", {})
                labels = ["Positive", "Negative", "Neutral"]
                values = [
                    sentiment.get("positive", 0),
                    sentiment.get("negative", 0),
                    sentiment.get("neutral", 0),
                ]
                if sum(values) > 0:
                    fig = px.pie(
                        names=labels,
                        values=values,
                        title="Sentiment Breakdown",
                        color=labels,
                        color_discrete_map={"Positive": "green", "Negative": "red", "Neutral": "gray"},
                    )
                    st.plotly_chart(fig)
                else:
                    st.warning("No sentiment data available.")

                # Audience Reactions
                st.subheader("ğŸ’¬ Audience Reactions")
                audience_reactions = analysis.get("audienceReactions", {})
                st.write(audience_reactions.get("summary", "No data available."))
                st.write("**Polarization:**", audience_reactions.get("polarization", "Not available."))
                st.write("**Spoilers:**", audience_reactions.get("spoilers", "Not available."))

                # Key Aspects Ratings
                st.subheader("ğŸ­ Key Aspects Ratings")
                key_aspects = analysis.get("keyAspects", {})
                if key_aspects:
                    aspect_labels = list(key_aspects.keys())
                    aspect_values = [aspect["score"] if isinstance(aspect["score"], int) else 0 for aspect in key_aspects.values()]
                    fig = px.bar(x=aspect_labels, y=aspect_values, title="Key Aspects Ratings",
                                 labels={"x": "Aspect", "y": "Rating"}, color=aspect_values)
                    st.plotly_chart(fig)
                else:
                    st.warning("No key aspect ratings available.")

                # Common Praises & Complaints
                st.subheader("ğŸ‘ Common Praise & ğŸ‘ Complaints")
                col1, col2 = st.columns(2)
                with col1:
                    st.write("**âœ… Praise:**")
                    praises = analysis.get("commonPraise", [])
                    for praise in praises:
                        st.write(f"- {praise}")

                with col2:
                    st.write("**âŒ Complaints:**")
                    complaints = analysis.get("commonComplaints", [])
                    for complaint in complaints:
                        st.write(f"- {complaint}")

                # Similar Movies
                st.subheader("ğŸ¬ Similar Movies")
                similar_movies = analysis.get("similarMovies", [])
                for movie in similar_movies:
                    st.write(f"ğŸï¸ **{movie['title']} ({movie['year']})** - {movie['similarity']}")

                # Final Verdict
                st.subheader("ğŸ† Final Verdict")
                final_verdict = analysis.get("finalVerdict", {})
                st.write("**Who Would Enjoy:**", final_verdict.get("whoWouldEnjoy", "Not available."))
                st.write("**Who Would Not Enjoy:**", final_verdict.get("whoWouldNotEnjoy", "Not available."))
                st.write("**Theater vs Streaming:**", final_verdict.get("theaterVsStreaming", "Not available."))

                # Limitations
                st.subheader("âš ï¸ Limitations")
                st.write(analysis.get("limitations", "No data available."))

            else:
                st.error("ğŸš¨ Error fetching movie analysis. Please try again.")
    else:
        st.warning("âš ï¸ Please enter a movie name.")